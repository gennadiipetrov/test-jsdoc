В Js есть простые типы данных и объекты. Всего встроенных типов - 8. Также можно создавать кастомные типы - это объекты. В Javascript у переменных нет типов - типы есть у значений. Можно также разделить типы на ссылочные типы и value типы.

Например,

```js
var a = 42;
typeof a;  // number
a = true;
typeof a;  // boolean
```

Типы Js:

* *number* - числа от -2^53 до 2^53. Целые и вещественные; 

* *bigint* - числа произвольной длины;

* *string* - строки;

* *boolean* - логические типы;

* *null* - для неизвестных значений;

* *undefined* - для неприсвоенных значений;

* *object* - для сложных структур (array, объекты);

* *symbol* - для уникальных идентификаторов;


*undefined* - тип который содержит такое же значение.

```js
var a;
typeof a; // undefined 
typeof b; // undefined 
```

Интересен факт, что *b* не объявлен, но ошибки в консоль не выводится, за счет *typeof*. Такая особенность *typeof*. Это может пригодится для безопасной проверки наличия каких-то переменных, например полифилов. Строки в JS имутабельны, поэтому обратится к определенному символу и изменить его нельзя, нужно применять функцию к строке и возвращать новую. Массивы же наоборот(чтобы строку перевести в массив можно использовать `Array.from`). Поэтому в таких случаях иногда переводят строку в массив и выполняют какие-то преобразования.

Например надо сделать реверс строки

```js
var c = a.split("").reverse().join(""); 
```

*Number* - подчиняется спецификации IEEE754. Числа пишутся в формате `45.0` или `45.` или `45`. Так вот запись `45.toFixed()` - не будет работать, потому что точка будет интерпретироваться как `45.` число. Чтобы это исправить ставят 2 точки или в круглые скобки оборачивают число `45..toFixed()`. Еще есть void - он стирает значение, записывая в него undefined. Нужно это например, чтобы функция возвращала какую-то другую функцию, возвращающую значение, но чтобы его затереть, чтобы не писать в 2 строки в общем. То есть вместо

```js
...
setTimeout()
return

// пишут так

return void setTimeout
```

# Преобразование типов

В Js типы преобразуются неявно, но можно использовать String, Number, Boolean для явного преобразования.

В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:

* Вызывает obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует, и передаёт ему хинт.
* Иначе, если хинт равен "string" пытается вызвать obj.toString(), а если его нет, то obj.valueOf(), если он существует.
* В случае, если хинт равен "number" или "default" пытается вызвать obj.valueOf(), а если его нет, то obj.toString(), если он существует.

[Преобразование](https://learn.javascript.ru/object-toprimitive)

*String(value)* - явно все преобразует в строку, н-р false -> "false", NaN -> " NaN"

*Number(value)*

```js
undefined -> NaN
null, "", false -> 0
true -> 1
"123" -> 123
"123X" -> NaN
Infinity -> Infinity
```

*Boolean(value)*

```js
0, null, undefined, NaN, "" -> false

Infinity, -1, " ", "test", 123 -> true
```

Все операции "+" рассматриваются как канкатенации, например 

```js
"2" + 4 = "24"
"2" - 2 = 0
undefined + 2 = NaN, так как undefined преобразуется в NaN
```

# Сравнение == и ===

**==** - сравнение двух величин с использование преобразования.

Если один из членов операции сравнения отличен от другого, то происходят преобразования. Сначала до строковых значений, затем до числовых.


```js
Например, 
'2' == 2
true == 1
false == 0
'' == false
```

**===** - сравнение двух величин без преобразования.

```js
Например, 
'2' === 2
false === 0
```

Есть еще один интересный пример:

```js
new String("a") == new String("a") // false
"a" == new String("a") // true
```

Потому что преобразования к примитивному значению тут не происходит, а значения ссылок не равны. Если же в одной из частей будет примитивное значение, то преобразование объекта к примитивному значению произойдет. Операции равенства врут для -0, `NaN`. Чтобы проверить переменную на `NaN` используют `Number.isNaN`. А чтобы сделать проверку на `-0`, надо свою функцию писать

```js
var r = Number(g); // где g вероятно -0 или "-0"

(r === 0) && (1/r === - infinity)
```

Чтобы такого не делать в es6 появилась функция `Object.is`. Которая адекватно все может сравнить. Следующие диаграммы взяты с 

[stackoverflow](https://stackoverflow.com/questions/3586775/what-is-the-correct-way-to-check-for-string-equality-in-javascript)

для `==`

![Диаграмма](https://i.stack.imgur.com/nkpj6.png)

для `===`

![Диаграмма](https://i.stack.imgur.com/DIqvq.png)


# Array, Date, Regexp, Set, Map, WeakMap ...

*Set, WeakMap, Map* и тд - в разной литературе по-разному, кто-то их называет типами, на MDN их называют глобальными объектами глобальные объекты, которые наследуются от Object.

Проверить тип можно по внутреннему полю `[[Class]]`:

```js
Object.prototype.toString.call(null); \\ [object Null]
Object.prototype.toString.call(undefined); \\ [object Undefined]
Object.prototype.toString.call(new WeakMap()); \\ [object Undefined]
Object.prototype.toString.call({}); \\ [object Object]
Object.prototype.toString.call([]); \\ [object Array]
Object.prototype.toString.call(1); \\ [object Number]
Object.prototype.toString.call(""); \\ [object String]
```

## Откуда у простых типов свойства?

Js движок конвертирует примитивный тип в объект String и на прототипе этого объекта уже будут функции. Переопределить метод на примитивном типе нельзя, так как после выполнения функции - объект обертка уничтожается(происходит что-то типа boxing\unboxing). Тоже касается и например Number и других.

```js
123..toString() 
```

Тут 2 точки потому что перавя точка относится к числу, например 123 иожно записать как 123. или 123.0, а вторая точка - это доступ к обертке с методами.